<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Graficador de Desigualdades Lineales</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;background:#f6f6f6;margin:0;padding:20px;display:flex;flex-direction:column;align-items:center;gap:12px}
  h2{margin:0 0 8px 0}
  textarea{width:580px;height:90px;padding:8px;font-size:14px;border:1px solid #ccc;border-radius:8px;resize:none}
  button{padding:8px 14px;border:none;border-radius:8px;background:#0077ff;color:#fff;font-weight:bold;cursor:pointer;transition:background .2s}
  button:hover{background:#0059c9}
  #canvas{border:1px solid #333;border-radius:8px;background:#fff}
  .controls{display:flex;gap:8px}
  label{font-size:14px;margin-bottom:4px;display:block}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.1/math.min.js"></script>
</head>
<body>
  <h2>Graficador de Desigualdades Lineales (2 variables)</h2>
  <label for="ineqInput">Escribe cada desigualdad en una línea. Ejemplos:<br>
    <code>4*x+2*y<=100</code>, <code>x+3*y>=60</code>, <code>x>=0</code>, <code>y<=15</code></label>
  <textarea id="ineqInput" placeholder="Ingresa desigualdades una por línea..."></textarea>
  <div class="controls">
    <button onclick="draw()">Graficar región factible</button>
    <button onclick="zoom(10)">+</button>
    <button onclick="zoom(-10)">-</button>
  </div>
  <canvas id="canvas" width="600" height="600"></canvas>
  <p style="font-size:13px;color:#555">La región amarilla corresponde al conjunto de puntos que cumplen simultáneamente todas las desigualdades.</p>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const W = canvas.width, H = canvas.height;
let scale = 40; // píxeles por unidad

function origin(){ return {x:W/2, y:H/2}; }

/** Utilidad para parsear desigualdad y generar función evaluadora */
function parseIneq(str){
  const ops = ["<=", ">=", "<", ">", "="];  
  let opFound = ops.find(op=> str.includes(op));
  if(!opFound) throw Error("Operador no reconocido en " + str);
  const [lhs,rhs] = str.split(opFound);
  const lhsJS = math.parse(lhs).toString();
  const rhsJS = math.parse(rhs).toString();
  // construimos una función booleana (x,y) => expr
  const expr = `( ${lhsJS} ) - ( ${rhsJS} )`;
  let cond;
  switch(opFound){
    case "<=": cond = `${expr} <= 1e-10`; break;
    case "<":  cond = `${expr} < 0`; break;
    case ">=": cond = `${expr} >= -1e-10`; break;
    case ">":  cond = `${expr} > 0`; break;
    case "=":  cond = `Math.abs(${expr}) < 1e-10`; break;
  }
  const testFunc = new Function("x","y",`return ${cond};`);
  return {op:opFound,test:testFunc,raw:str};
}

function clearCanvas(){
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle="#ffffff";
  ctx.fillRect(0,0,W,H);
  // grid
  ctx.lineWidth=1;ctx.strokeStyle="#e9e9e9";
  for(let x=0;x<=W;x+=scale){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,H);ctx.stroke();}
  for(let y=0;y<=H;y+=scale){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(W,y);ctx.stroke();}
  // axes
  const o=origin();
  ctx.strokeStyle="#000";ctx.lineWidth=1.5;
  ctx.beginPath();ctx.moveTo(0,o.y);ctx.lineTo(W,o.y);ctx.moveTo(o.x,0);ctx.lineTo(o.x,H);ctx.stroke();
  ctx.font="11px Arial";ctx.fillStyle="#000";
  for(let i=-Math.floor(o.x/scale);i<=Math.floor((W-o.x)/scale);i++){if(i!==0)ctx.fillText(i,o.x+i*scale-5,o.y+12);}  
  for(let i=-Math.floor(o.y/scale);i<=Math.floor((H-o.y)/scale);i++){if(i!==0)ctx.fillText(-i,o.x+5,o.y+i*scale+4);}  
}

function draw(){
  const linesRaw = document.getElementById("ineqInput").value.split(/\n|;/).map(s=>s.trim()).filter(Boolean);
  if(linesRaw.length===0){alert("Ingresa al menos una desigualdad");return;}
  let ineqs=[];
  try{ ineqs = linesRaw.map(parseIneq);}catch(e){alert(e.message);return;}
  clearCanvas();
  const o=origin();
  // sombrear región factible evaluando cada pixel (paso grueso = 2px para rendimiento)
  const step=2;
  const imgData = ctx.getImageData(0,0,W,H);
  const data = imgData.data;
  for(let px=0; px<W; px+=step){
    for(let py=0; py<H; py+=step){
      const x = (px - o.x)/scale;
      const y = (o.y - py)/scale;
      const ok = ineqs.every(eq=>eq.test(x,y));
      if(ok){
        for(let dx=0;dx<step;dx++)for(let dy=0;dy<step;dy++){
          const idx = ((py+dy)*W + (px+dx))*4;
          data[idx]=255;      // R
          data[idx+1]=255;    // G
          data[idx+2]=150;    // B
          data[idx+3]=120;    // alpha
        }
      }
    }
  }
  ctx.putImageData(imgData,0,0);

  // dibujar líneas frontera (sampleando puntos)
  ineqs.forEach((ineq,i)=>{
    ctx.beginPath(); ctx.lineWidth=2; ctx.strokeStyle=["#008000","#800080","#d00000","#0044aa"][i%4];
    let started=false;
    for(let px=0;px<=W;px++){
      const x = (px - o.x)/scale;
      // buscamos y que satisfaga igualdad aproximada
      let found=false, pyFound=0;
      for(let py=0;py<=H;py+=1){
        const y = (o.y - py)/scale;
        const diff = Math.abs( (Function("x","y","return ("+ineq.raw.replace(/<=|>=|=|<|>/,"-")+ ")")(x,y)) );
        if(diff<1e-2){found=true;pyFound=py;break;}
      }
      if(found){
        if(!started){ctx.moveTo(px,pyFound);started=true;}else{ctx.lineTo(px,pyFound);}
      }
    }
    ctx.stroke();
  });
}

function zoom(delta){
  scale = Math.max(10,scale+delta);
  draw();
}

clearCanvas();
</script>
</body>
</html>
